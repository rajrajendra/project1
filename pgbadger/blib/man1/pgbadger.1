.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PGBADGER 1"
.TH PGBADGER 1 "2015-05-06" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
pgBadger \- a fast PostgreSQL log analysis report
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Usage: pgbadger [options] logfile [...]
.PP
.Vb 1
\&        PostgreSQL log analyzer with fully detailed reports and graphs.
.Ve
.PP
Arguments:
.PP
.Vb 3
\&    logfile can be a single log file, a list of files, or a shell command
\&    returning a list of files. If you want to pass log content from stdin
\&    use \- as filename. Note that input from stdin will not work with csvlog.
.Ve
.PP
Options:
.PP
.Vb 10
\&    \-a | \-\-average minutes : number of minutes to build the average graphs of
\&                             queries and connections. Default 5 minutes.
\&    \-A | \-\-histo\-avg minutes: number of minutes to build the histogram graphs
\&                             of queries. Default 60 minutes.
\&    \-b | \-\-begin datetime  : start date/time for the data to be parsed in log.
\&    \-B | \-\-bar\-graph       : use bar graph instead of line by default.
\&    \-c | \-\-dbclient host   : only report on entries for the given client host.
\&    \-C | \-\-nocomment       : remove comments like /* ... */ from queries.
\&    \-d | \-\-dbname database : only report on entries for the given database.
\&    \-D | \-\-dns\-resolv      : client ip adresses are replaced by their DNS name.
\&                             Be warned that this can really slow down pgBadger.
\&    \-e | \-\-end datetime    : end date/time for the data to be parsed in log.
\&    \-f | \-\-format logtype  : possible values: syslog,stderr,csv. Default: stderr.
\&    \-G | \-\-nograph         : disable graphs on HTML output. Enabled by default.
\&    \-h | \-\-help            : show this message and exit.
\&    \-i | \-\-ident name      : programname used as syslog ident. Default: postgres
\&    \-I | \-\-incremental     : use incremental mode, reports will be generated by
\&                             days in a separate directory, \-\-outdir must be set.
\&    \-j | \-\-jobs number     : number of jobs to run at same time. Default is 1,
\&                             run as single process.
\&    \-J | \-\-Jobs number     : number of log file to parse in parallel. Default
\&                             is 1, run as single process.
\&    \-l | \-\-last\-parsed file: allow incremental log parsing by registering the
\&                             last datetime and line parsed. Useful if you want
\&                             to watch errors since last run or if you want one
\&                             report per day with a log rotated each week.
\&    \-m | \-\-maxlength size  : maximum length of a query, it will be restricted to
\&                             the given size. Default: no truncate
\&    \-M | \-\-no\-multiline    : do not collect multiline statement to avoid garbage
\&                             especially on errors that generate a huge report.
\&    \-n | \-\-nohighlight     : disable SQL code highlighting.
\&    \-N | \-\-appname name    : only report on entries for given application name
\&    \-o | \-\-outfile filename: define the filename for the output. Default depends
\&                             on the output format: out.html, out.txt, out.bin,
\&                             out.json or out.tsung.
\&                             With module JSON::XS installed, you can output file
\&                             in JSON format either.
\&                             To dump output to stdout use \- as filename.
\&    \-O | \-\-outdir path     : directory where out file must be saved.
\&    \-p | \-\-prefix string   : the value of your custom log_line_prefix as
\&                             defined in your postgresql.conf. Only use it if you
\&                             aren\*(Aqt using one of the standard prefixes specified
\&                             in the pgBadger documentation, such as if your prefix
\&                             includes additional variables like client ip or
\&                             application name. See examples below.
\&    \-P | \-\-no\-prettify     : disable SQL queries prettify formatter.
\&    \-q | \-\-quiet           : don\*(Aqt print anything to stdout, not even a progress bar.
\&    \-r | \-\-remote\-host ip  : set the host where to execute the cat command on remote
\&                             logfile to parse localy the file.
\&    \-R | \-\-retention N     : number of week to keep in incremental mode. Default 0,
\&                             disabled. Used to set the number of weel to keep in
\&                             output directory. Older week end day directory are
\&                             automatically removed.
\&    \-s | \-\-sample number   : number of query samples to store/display. Default: 3
\&    \-S | \-\-select\-only     : only report SELECT queries.
\&    \-t | \-\-top number      : number of queries to store/display. Default: 20
\&    \-T | \-\-title string    : change title of the HTML page report.
\&    \-u | \-\-dbuser username : only report on entries for the given user.
\&    \-U | \-\-exclude\-user username : exclude entries for the specified user from report.
\&    \-v | \-\-verbose         : enable verbose or debug mode. Disabled by default.
\&    \-V | \-\-version         : show pgBadger version and exit.
\&    \-w | \-\-watch\-mode      : only report errors just like logwatch could do.
\&    \-x | \-\-extension       : output format. Values: text, html, bin, json or
\&                             tsung. Default: html
\&    \-X | \-\-extra\-files     : in incremetal mode allow pgbadger to write CSS and JS
\&                             files in the output directory as separate files.
\&    \-z | \-\-zcat exec_path  : set the full path to the zcat program. Use it if
\&                             zcat or bzcat or unzip is not in your path.
\&    \-\-pie\-limit num        : pie data lower than num% will show a sum instead.
\&    \-\-exclude\-query regex  : any query matching the given regex will be excluded
\&                             from the report. For example: "^(VACUUM|COMMIT)"
\&                             You can use this option multiple times.
\&    \-\-exclude\-file filename: path of the file which contains all the regex to use
\&                             to exclude queries from the report. One regex per line.
\&    \-\-include\-query regex  : any query that does not match the given regex will be
\&                             excluded from the report. For example: "(table_1|table_2)"
\&                             You can use this option multiple times.
\&    \-\-include\-file filename: path of the file which contains all the regex of the
\&                             queries to include from the report. One regex per line.
\&    \-\-disable\-error        : do not generate error report.
\&    \-\-disable\-hourly       : do not generate hourly report.
\&    \-\-disable\-type         : do not generate report of queries by type, database...
\&    \-\-disable\-query        : do not generate query reports (slowest, most
\&                             frequent, queries by users, by database, ...).
\&    \-\-disable\-session      : do not generate session report.
\&    \-\-disable\-connection   : do not generate connection report.
\&    \-\-disable\-lock         : do not generate lock report.
\&    \-\-disable\-temporary    : do not generate temporary report.
\&    \-\-disable\-checkpoint   : do not generate checkpoint/restartpoint report.
\&    \-\-disable\-autovacuum   : do not generate autovacuum report.
\&    \-\-charset              : used to set the HTML charset to be used. Default: utf\-8.
\&    \-\-csv\-separator        : used to set the CSV field separator, default: ,
\&    \-\-exclude\-time  regex  : any timestamp matching the given regex will be
\&                             excluded from the report. Example: "2013\-04\-12 .*"
\&                             You can use this option multiple times.
\&    \-\-exclude\-appname name : exclude entries for the specified application name
\&                             from report. Example: "pg_dump".
\&    \-\-exclude\-line regex   : pgbadger will start to exclude any log entry that
\&                             will match the given regex. Can be used multiple time.
\&    \-\-anonymize            : obscure all literals in queries to hide confidential data.
.Ve
.PP
pgBadger is able to parse a remote log file using a passwordless ssh connection.
Use the \-r or \-\-remote\-host to set the host ip address or hostname. There's also
some additional options to fully control the ssh connection.
.PP
.Vb 8
\&    \-\-ssh\-program ssh        path to the ssh program to use. Default: ssh.
\&    \-\-ssh\-user username      connection login name. Default to running user.
\&    \-\-ssh\-identity file      path to the identity file to use.
\&    \-\-ssh\-timeout second     timeout to ssh connection failure. Default 10 seconds.
\&    \-\-ssh\-options  options   list of \-o options to use for the ssh connection. Options
\&                             always used:
\&                                 \-o ConnectTimeout=$ssh_timeout
\&                                 \-o PreferredAuthentications=hostbased,publickey
.Ve
.PP
Examples:
.PP
.Vb 10
\&        pgbadger /var/log/postgresql.log
\&        pgbadger /var/log/postgres.log.2.gz /var/log/postgres.log.1.gz 
\&                       /var/log/postgres.log
\&        pgbadger /var/log/postgresql/postgresql\-2012\-05\-*
\&        pgbadger \-\-exclude\-query="^(COPY|COMMIT)" /var/log/postgresql.log
\&        pgbadger \-b "2012\-06\-25 10:56:11" \-e "2012\-06\-25 10:59:11" 
\&                       /var/log/postgresql.log
\&        cat /var/log/postgres.log | pgbadger \-
\&        # Log prefix with stderr log output
\&        perl pgbadger \-\-prefix \*(Aq%t [%p]: [%l\-1] user=%u,db=%d,client=%h\*(Aq 
\&                        /pglog/postgresql\-2012\-08\-21*
\&        perl pgbadger \-\-prefix \*(Aq%m %u@%d %p %r %a : \*(Aq /pglog/postgresql.log
\&        # Log line prefix with syslog log output
\&        perl pgbadger \-\-prefix \*(Aquser=%u,db=%d,client=%h,appname=%a\*(Aq 
\&                        /pglog/postgresql\-2012\-08\-21*
\&        # Use my 8 CPUs to parse my 10GB file faster, much faster
\&        perl pgbadger \-j 8 /pglog/postgresql\-9.1\-main.log
.Ve
.PP
Generate Tsung sessions \s-1XML\s0 file with select queries only:
.PP
.Vb 1
\&    perl pgbadger \-S \-o sessions.tsung \-\-prefix \*(Aq%t [%p]: [%l\-1] user=%u,db=%d \*(Aq /pglog/postgresql\-9.1.log
.Ve
.PP
Reporting errors every week by cron job:
.PP
.Vb 1
\&    30 23 * * 1 /usr/bin/pgbadger \-q \-w /var/log/postgresql.log \-o /var/reports/pg_errors.html
.Ve
.PP
Generate report every week using incremental behavior:
.PP
.Vb 2
\&    0 4 * * 1 /usr/bin/pgbadger \-q \`find /var/log/ \-mtime \-7 \-name "postgresql.log*"\` 
\&        \-o /var/reports/pg_errors\-\`date +%F\`.html \-l /var/reports/pgbadger_incremental_file.dat
.Ve
.PP
This supposes that your log file and \s-1HTML\s0 report are also rotated every week.
.PP
Or better, use the auto-generated incremental reports:
.PP
.Vb 2
\&    0 4 * * * /usr/bin/pgbadger \-I \-q /var/log/postgresql/postgresql.log.1 
\&        \-O /var/www/pg_reports/
.Ve
.PP
will generate a report per day and per week.
.PP
In incremental mode, you can also specify the number of week to keep in the reports:
.PP
.Vb 2
\&    /usr/bin/pgbadger \-\-retention 2 \-I \-q /var/log/postgresql/postgresql.log.1 
\&        \-O /var/www/pg_reports/
.Ve
.PP
If you have a pg_dump at 23:00 and 13:00 each day during half an hour, you can
use pgbadger as follow to exclude these period from the report:
.PP
.Vb 1
\&    pgbadger \-\-exclude\-time "2013\-09\-.* (23|13):.*" postgresql.log
.Ve
.PP
This will help avoid having \s-1COPY\s0 statements, as generated by pg_dump, on top of
the list of slowest queries. You can also use \-\-exclude\-appname \*(L"pg_dump\*(R" to
solve this problem in a simpler way.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
pgBadger is a PostgreSQL log analyzer build for speed with fully detailed reports from your PostgreSQL log file. It's a single and small Perl script that outperform any other PostgreSQL log analyzer.
.PP
It is written in pure Perl language and uses a javascript library (flotr2) to draw graphs so that you don't need to install any additional Perl modules or other packages. Furthermore, this library gives us more features such as zooming. pgBadger also uses the Bootstrap javascript library and the FontAwesome webfont for better design. Everything is embedded.
.PP
pgBadger is able to autodetect your log file format (syslog, stderr or csvlog). It is designed to parse huge log files as well as gzip compressed file. See a complete list of features below. Supported compressed format are gzip, bzip2 and xz. For the last one you must have a xz version upper than 5.05 that support the \-\-robot option.
.PP
All charts are zoomable and can be saved as \s-1PNG\s0 images.
.PP
You can also limit pgBadger to only report errors or remove any part of the report using command line options.
.PP
pgBadger supports any custom format set into log_line_prefix of your postgresql.conf file provide that you use the \f(CW%t\fR, \f(CW%p\fR and \f(CW%l\fR patterns.
.PP
pgBadger allow parallel processing on a single log file and multiple files through the use of the \-j option and the number of CPUs as value.
.PP
If you want to save system performance you can also use log_duration instead of log_min_duration_statement to have reports on duration and number of queries only.
.SH "FEATURE"
.IX Header "FEATURE"
pgBadger reports everything about your \s-1SQL\s0 queries:
.PP
.Vb 10
\&        Overall statistics
\&        The most frequent waiting queries.
\&        Queries that waited the most.
\&        Queries generating the most temporary files.
\&        Queries generating the largest temporary files.
\&        The slowest queries.
\&        Queries that took up the most time.
\&        The most frequent queries.
\&        The most frequent errors.
\&        Histogram of query times.
.Ve
.PP
The following reports are also available with hourly charts divide by periods of
five minutes:
.PP
.Vb 4
\&        SQL queries statistics.
\&        Temporary file statistics.
\&        Checkpoints statistics.
\&        Autovacuum and autoanalyze statistics.
.Ve
.PP
There's also some pie reports of distribution about:
.PP
.Vb 6
\&        Locks statistics.
\&        ueries by type (select/insert/update/delete).
\&        Distribution of queries type per database/application
\&        Sessions per database/user/client.
\&        Connections per database/user/client.
\&        Autovacuum and autoanalyze per table.
.Ve
.PP
All charts are zoomable and can be saved as \s-1PNG\s0 images. \s-1SQL\s0 queries reported are
highlighted and beautified automatically.
.PP
You can also have incremental reports with one report per day and a cumulative
report per week. Two multiprocess modes are available to speed up log parsing,
one using one core per log file, and the second to use multiple core to parse
a single file. Both modes can be combined.
.PP
Histogram granularity can be adjusted using the \-A command line option. By default
they will report the mean of each top queries/error occuring per hour, but you can
specify the granularity down to the minute.
.PP
pgBadger can also be used in a central place to parse remote log files using a
password less \s-1SSH\s0 connection. This mode can be used with compressed files and
in mode multiprocess per file (\-J) but can not be used with \s-1CSV\s0 log format.
.SH "REQUIREMENT"
.IX Header "REQUIREMENT"
pgBadger comes as a single Perl script \- you do not need anything other than a modern
Perl distribution. Charts are rendered using a Javascript library so you don't need
anything. Your browser will do all the work.
.PP
If you planned to parse PostgreSQL \s-1CSV\s0 log files you might need some Perl Modules:
.PP
.Vb 1
\&        Text::CSV_XS \- to parse PostgreSQL CSV log files.
.Ve
.PP
This module is optional, if you don't have PostgreSQL log in the \s-1CSV\s0 format you don't
need to install it.
.PP
If you want to export statistics as \s-1JSON\s0 file you need an additional Perl module:
.PP
.Vb 1
\&        JSON::XS \- JSON serialising/deserialising, done correctly and fast
.Ve
.PP
This module is optional, if you don't select the json output format you don't
need to install it.
.PP
Compressed log file format is autodetected from the file exension. If pgBadger find
a gz extension it will use the zcat utility, with a bz2 extension it will use bzcat
and if the file extension is zip or xz then the unzip or xz utilities will be used.
.PP
If those utilities are not found in the \s-1PATH\s0 environment variable then use the \-\-zcat
command line option to change this path. For example:
.PP
.Vb 2
\&        \-\-zcat="/usr/local/bin/gunzip \-c" or \-\-zcat="/usr/local/bin/bzip2 \-dc"
\&        \-\-zcat="C:\etools\eunzip \-p"
.Ve
.PP
By default pgBadger will use the zcat, bzcat and unzip utilities following the
file extension. If you use the default autodetection compress format you can
mixed gz, bz2, xz or zip files. Specifying a custom value to \-\-zcat option will
remove this feature of mixed compressed format.
.PP
Note that multiprocessing can not be used with compressed files or \s-1CSV\s0 files as
well as under Windows platform.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Download the tarball from github and unpack the archive as follow:
.PP
.Vb 4
\&        tar xzf pgbadger\-5.x.tar.gz
\&        cd pgbadger\-5.x/
\&        perl Makefile.PL
\&        make && sudo make install
.Ve
.PP
This will copy the Perl script pgbadger to /usr/local/bin/pgbadger by default and the
man page into /usr/local/share/man/man1/pgbadger.1. Those are the default installation
directories for 'site' install.
.PP
If you want to install all under /usr/ location, use INSTALLDIRS='perl' as an argument
of Makefile.PL. The script will be installed into /usr/bin/pgbadger and the manpage
into /usr/share/man/man1/pgbadger.1.
.PP
For example, to install everything just like Debian does, proceed as follows:
.PP
.Vb 1
\&        perl Makefile.PL INSTALLDIRS=vendor
.Ve
.PP
By default \s-1INSTALLDIRS\s0 is set to site.
.SH "POSTGRESQL CONFIGURATION"
.IX Header "POSTGRESQL CONFIGURATION"
You must enable and set some configuration directives in your postgresql.conf
before starting.
.PP
You must first enable \s-1SQL\s0 query logging to have something to parse:
.PP
.Vb 1
\&        log_min_duration_statement = 0
.Ve
.PP
Here every statement will be logged, on busy server you may want to increase
this value to only log queries with a higher duration time. Note that if you have
log_statement set to 'all' nothing will be logged through log_min_duration_statement.
See next chapter for more information.
.PP
With 'stderr' log format, log_line_prefix must be at least:
.PP
.Vb 1
\&        log_line_prefix = \*(Aq%t [%p]: [%l\-1] \*(Aq
.Ve
.PP
Log line prefix could add user and database name as follows:
.PP
.Vb 1
\&        log_line_prefix = \*(Aq%t [%p]: [%l\-1] user=%u,db=%d \*(Aq
.Ve
.PP
or for syslog log file format:
.PP
.Vb 1
\&        log_line_prefix = \*(Aquser=%u,db=%d \*(Aq
.Ve
.PP
Log line prefix for stderr output could also be:
.PP
.Vb 1
\&        log_line_prefix = \*(Aq%t [%p]: [%l\-1] db=%d,user=%u \*(Aq
.Ve
.PP
or for syslog output:
.PP
.Vb 1
\&        log_line_prefix = \*(Aqdb=%d,user=%u \*(Aq
.Ve
.PP
You need to enable other parameters in postgresql.conf to get more information from your log files:
.PP
.Vb 6
\&        log_checkpoints = on
\&        log_connections = on
\&        log_disconnections = on
\&        log_lock_waits = on
\&        log_temp_files = 0
\&        log_autovacuum_min_duration = 0
.Ve
.PP
Do not enable log_statement as their log format will not be parsed by pgBadger.
.PP
Of course your log messages should be in English without locale support:
.PP
.Vb 1
\&        lc_messages=\*(AqC\*(Aq
.Ve
.PP
but this is not only recommended by pgBadger.
.PP
Note: the session line [%l\-1] is just used to match the default prefix for \*(L"stderr\*(R".
The \-1 has no real purpose and basically is not used in Pgbadger statistics / graphs.
You can safely removed them from the log_line_prefix but you will need to set the
\&\-\-prefix command line option.
.SH "log_min_duration_statement, log_duration and log_statement"
.IX Header "log_min_duration_statement, log_duration and log_statement"
If you want full statistics reports you must set log_min_duration_statement
to 0 or more milliseconds.
.PP
If you just want to report duration and number of queries and don't want all
details about queries, set log_min_duration_statement to \-1 to disable it and
enable log_duration in your postgresql.conf file. If you want to add the most
common request report you can either choose to set log_min_duration_statement
to a higher value or choose to enable log_statement.
.PP
Enabling log_min_duration_statement will add reports about slowest queries and
queries that took up the most time. Take care that if you have log_statement
set to 'all' nothing will be logged with log_line_prefix.
.SH "PARALLEL PROCESSING"
.IX Header "PARALLEL PROCESSING"
To enable parallel processing you just have to use the \-j N option where N is
the number of cores you want to use.
.PP
pgbadger will then proceed as follow:
.PP
.Vb 10
\&        for each log file
\&            chunk size = int(file size / N)
\&            look at start/end offsets of these chunks
\&            fork N processes and seek to the start offset of each chunk
\&                each process will terminate when the parser reach the end offset
\&                of its chunk
\&                each process write stats into a binary temporary file
\&           wait for all children has terminated
\&        All binary temporary files generated will then be read and loaded into
\&        memory to build the html output.
.Ve
.PP
With that method, at start/end of chunks pgbadger may truncate or omit a
maximum of N queries perl log file which is an insignificant gap if you have
millions of queries in your log file. The chance that the query that you were
looking for is loose is near 0, this is why I think this gap is livable. Most
of the time the query is counted twice but truncated.
.PP
When you have lot of small log files and lot of CPUs it is speedier to dedicate
one core to one log file at a time. To enable this behavior you have to use
option \-J N instead. With 200 log files of 10MB each the use of the \-J option
start being really interesting with 8 Cores. Using this method you will be sure
to not loose any queries in the reports.
.PP
He are a benchmarck done on a server with 8 CPUs and a single file of 9.5GB.
.PP
.Vb 4
\&         Option |  1 CPU  | 2 CPU | 4 CPU | 8 CPU
\&        \-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-
\&           \-j   | 1h41m18 | 50m25 | 25m39 | 15m58
\&           \-J   | 1h41m18 | 54m28 | 41m16 | 34m45
.Ve
.PP
With 200 log files of 10MB each and a total og 2GB the results are slightly
different:
.PP
.Vb 4
\&         Option | 1 CPU | 2 CPU | 4 CPU | 8 CPU
\&        \-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-
\&           \-j   | 20m15 |  9m56 |  5m20 | 4m20
\&           \-J   | 20m15 |  9m49 |  5m00 | 2m40
.Ve
.PP
So it is recommanded to use \-j unless you have hundred of small log file
and can use at least 8 CPUs.
.PP
\&\s-1IMPORTANT:\s0 when you are using parallel parsing pgbadger will generate a lot
of temporary files in the /tmp directory and will remove them at end, so do
not remove those files unless pgbadger is not running. They are all named
with the following template tmp_pgbadgerXXXX.bin so they can be easily identified.
.SH "INCREMENTAL REPORTS"
.IX Header "INCREMENTAL REPORTS"
pgBadger include an automatic incremental report mode using option \-I or
\&\-\-incremental. When running in this mode, pgBadger will generate one report
per day and a cumulative report per week. Output is first done in binary
format into the mandatory output directory (see option \-O or \-\-outdir),
then in \s-1HTML\s0 format for daily and weekly reports with a main index file.
.PP
The main index file will show a dropdown menu per week with a link to the week
report and links to daily reports of this week.
.PP
For example, if you run pgBadger as follow based on a daily rotated file:
.PP
.Vb 2
\&    0 4 * * * /usr/bin/pgbadger \-I \-q /var/log/postgresql/postgresql.log.1 \e
\&        \-O /var/www/pg_reports/
.Ve
.PP
you will have all daily and weekly reports for the full running period.
.PP
In this mode pgBagder will create an automatic incremental file into the
output directory, so you don't have to use the \-l option unless you want
to change the path of that file. This mean that you can run pgBadger in
this mode each days on a log file rotated each week, it will not count
the log entries twice.
.PP
To save disk space you may want to use the \-X or \-\-extra\-files command line
option to force pgBadger to write javascript and css to separate files in
the output directory. The resources will then be loaded using script and
link tag.
.SH "BINARY FORMAT"
.IX Header "BINARY FORMAT"
Using the binary format it is possible to create custom incremental and
cumulative reports. For example, if you want to refresh a pgbadger report
each hour from a daily PostgreSQl log file, you can proceed by running each
hour the following commands:
.PP
.Vb 1
\&    pgbadger \-\-last\-parsed .pgbadger_last_state_file \-o sunday/hourX.bin /var/log/pgsql/postgresql\-Sun.log
.Ve
.PP
to generate the incremental data files in binary format. And to generate the fresh \s-1HTML\s0
report from that binary file:
.PP
.Vb 1
\&    pgbadger sunday/*.bin
.Ve
.PP
Or an other example, if you have one log file per hour and you want a reports to be
rebuild each time the log file is switched. Proceed as follow:
.PP
.Vb 4
\&        pgbadger \-o day1/hour01.bin /var/log/pgsql/pglog/postgresql\-2012\-03\-23_10.log
\&        pgbadger \-o day1/hour02.bin /var/log/pgsql/pglog/postgresql\-2012\-03\-23_11.log
\&        pgbadger \-o day1/hour03.bin /var/log/pgsql/pglog/postgresql\-2012\-03\-23_12.log
\&        ...
.Ve
.PP
When you want to refresh the \s-1HTML\s0 report, for example each time after a new binary file
is generated, just do the following:
.PP
.Vb 1
\&        pgbadger \-o day1_report.html day1/*.bin
.Ve
.PP
Adjust the commands following your needs.
.SH "JSON FORMAT"
.IX Header "JSON FORMAT"
\&\s-1JSON\s0 format is good for sharing data with other languages, which makes it
easy to integrate pgBadger's result into other monitoring tools like Cacti
or Graphite.
.SH "AUTHORS"
.IX Header "AUTHORS"
pgBadger is an original work from Gilles Darold.
.PP
The pgBadger logo is an original creation of Damien Clochard.
.PP
The pgBadger v4.x design comes from the \*(L"Art is code\*(R" company.
.PP
This web site is a work of Gilles Darold.
.PP
pgBadger is maintained by Gilles Darold, the good folks at Dalibo, and every one who wants to contribute.
.PP
Many people have contributed to pgBadger, they are all quoted in the Changelog file.
.SH "LICENSE"
.IX Header "LICENSE"
pgBadger is free software distributed under the PostgreSQL Licence.
.PP
Copyright (c) 2012\-2014, Dalibo
.PP
A modified version of the SQL::Beautify Perl Module is embedded in pgBadger
with copyright (C) 2009 by Jonas Kramer and is published under the terms of
the Artistic License 2.0.
